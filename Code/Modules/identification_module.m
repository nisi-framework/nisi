function [Numerator_Order_Vector,Numerator_Parameter_Vector, ...          Denominator_Order_Vector,Denominator_Parameter_Vector, ...          Error_Numerator_Vector, Error_Denominator_Vector, ...          Simulated_Temperature_Vector, Impulse_Response ] =  ...          identification_module(Delta_t,Auto_Param_Finder,Max_Parameter_n_o,Max_Parameter_d_o,...          Parameter_Config_n,Parameter_Config_d,Manual_n_o,Manual_d_o, ...          Calibration_Temperature,Calibration_Heat_Flux)%% This module contains the identification procedurefprintf('Starting system identification \n')  %-----------------------------------------------------------------------% Manual parameter override via NISI main control file% If NISI.m manual override (N3 flag) is active, the nominator and% denominator settings from  Manual_n_o (N4) and Manual_d_o (N5) have% the following effect : %% If Autoparams is active, the algorithm chooses the possible% derivatives from N4 and N5, otherwise they act directly as% appropriate parameters. In both cases, the second row vector sets the% values for the identified parameter.%% If Autoparams is not active, the algorithm chooses the possible% derivatives from the parameter_conf.m file according to the settings% given from the parameter configuration in Parameter_Config_n(Nominator) and% Parameter_Config_d(Denominator). Manual_n_o and Manual_d_o act the same way as N4 and N5, except that% they only fix the second row vector for equal parameter derivatives%-----------------------------------------------------------------------    %-------------------------------------------------------------------%% Nominator_Grid definition %-------------------------------------------------------------------if Parameter_Config_n == 0 || ~Auto_Param_Finder   Numerator_Grid = Manual_n_o;else  [Numerator_Grid(1,:)] = parameter_conf(Parameter_Config_n,Max_Parameter_n_o);   Numerator_Grid(2,:)  = 0;   for i = 1:length(Manual_n_o(1,:))      [~, Position] = find(Numerator_Grid(1,:) == Manual_n_o(1,i));      if ~isempty(Position)          Numerator_Grid(2,Position) = Manual_n_o(2,i);       end   endend%-------------------------------------------------------------------%% Denominator_Grid definition (no manual override)%-------------------------------------------------------------------        if Parameter_Config_d == 0 ||~Auto_Param_Finder    Denominator_Grid = Manual_d_o;else                 [Denominator_Grid(1,:)] = parameter_conf(Parameter_Config_d,Max_Parameter_d_o);    Denominator_Grid(2,:)  = 0;    for i = 1:length(Manual_d_o(1,:))      [~, Position] = find(Denominator_Grid(1,:) == Manual_d_o(1,i));      if ~isempty(Position)          Denominator_Grid(2,Position) = Manual_d_o(2,i);       end    end        end  clear Parameter_Config_n Parameter_Config_d Manual_n_o Manual_d_o Discard Position      %-----------------------------------------------------------------------%% Loading Distribution Matrix % for automatic parameter association before main computation loop starts, also % Duration/Timer/Theta initialisation for automatic parameter selection%-----------------------------------------------------------------------if Auto_Param_Finder  %Flag for automatic parameter derivate association    filepath = ['distribution' num2str(Max_Parameter_n_o) '.mat'] ;   load(filepath);            Numerator_Distribution  = distrib;   clear distrib filepath       filepath = ['distribution' num2str(Max_Parameter_d_o) '.mat'] ;   load(filepath);            Denominator_Distribution = distrib;   clear distrib filepath           currentTimeStep = 0;   kk               = 0;    Theta(1:length(Numerator_Distribution(:,1)) *   ...           length(Denominator_Distribution(:,1)))  = 0;                           end   %-----------------------------------------------------------------------%% Main Identification Loop%-----------------------------------------------------------------------for i = 1:length(Calibration_Temperature(:,1,1))   for j = 1:length(Calibration_Temperature(:,1,1))      clear Transfer_Heat_Flux Transfer_Temperature Temperature_Derivatives Heat_Flux_Derivatives       Transfer_Heat_Flux(:,1)    = Calibration_Heat_Flux(i,j,:);   Transfer_Temperature(:,1)  = Calibration_Temperature(i,j,:);         Temperature_Derivatives    = derivative(Transfer_Temperature, Denominator_Grid, ...                                           Delta_t);   Heat_Flux_Derivatives      = derivative(Transfer_Heat_Flux, Numerator_Grid, ...                                           Delta_t);        if ~Auto_Param_Finder  %Flag for automatic parameter derivate association                  [Numerator_Order,Numerator_Parameter,Denominator_Order, ...        Denominator_Parameter,Error_Numerator,Error_Denominator] ...        = system_identification(Heat_Flux_Derivatives,Temperature_Derivatives, ...                               Numerator_Grid,Denominator_Grid, 1);%  Normalize the Parameters to alpha_M0 = 1 - das sollte dieselbe IR liefern, da in%  simulation_system ein etwaiger Skalierfaktor im Zähler und im Nenner steht und sich somit%  rauskürzt, ich, FH, habs erstmal weggelassen. Sollte erstmal genauer untersucht werden.%     TestFH = Denominator_Parameter(1,1);%     Denominator_Parameter = Denominator_Parameter/TestFH;%     Numerator_Parameter = Numerator_Parameter/TestFH;               [Simulated_Temperature] = simulation_system( ...                                 Numerator_Parameter, ...                                 Denominator_Parameter,Denominator_Order, ...                                 Delta_t,Transfer_Heat_Flux,Heat_Flux_Derivatives, 1);               else %Auto_Param_Finder         %% Calculate all possible numerator-denominator-combinations       for n = 1:length(Numerator_Distribution(:,1))          %-------------------------------------------------------------          % Constructor of the n_o matrix for system identification           % for the specific numerator distribution          %-------------------------------------------------------------                        clear Local_Numerator_Grid Transfer_Q_Derivatives Position         [Position]              = find(Numerator_Distribution(n,:));          for m = 1:length(Position)          Transfer_Q_Derivatives(:,m) =  Heat_Flux_Derivatives(:,Position(m));          end          for Generic_Counter = 1:length(Position)              Local_Numerator_Grid(:,Generic_Counter) = ...              Numerator_Grid(:,Position(Generic_Counter));          end                        for d = 1:length(Denominator_Distribution(:,1))            %-------------------------------------------------------------            % Constructor of the d_o matrix for system identification             % for the specific denominator distribution            %-------------------------------------------------------------                          clear m Local_Denominator_Grid Transfer_T_Derivatives Position            [Position]             = find(Denominator_Distribution(d,:));             for m = 1:length(Position)            Transfer_T_Derivatives(:,m) =  Temperature_Derivatives(:,Position(m));            end            for Generic_Counter = 1:length(Position)                Local_Denominator_Grid(:,Generic_Counter) = ...                Denominator_Grid(:,Position(Generic_Counter));            end            clear Position Generic_Counter                            % Reset Waitbars%                 multiWaitbar('System Identification',0);%                 multiWaitbar('Simulating Temperature',0);                            [~,Numerator_Parameter,Denominator_Order, ...             Denominator_Parameter,~,~] ...             = system_identification(Transfer_Q_Derivatives,Transfer_T_Derivatives, ...                                     Local_Numerator_Grid, Local_Denominator_Grid, 0);               [Simulated_Temperature] = simulation_system( Numerator_Parameter, Denominator_Parameter, ...                                      Denominator_Order, ...                                      Delta_t,Transfer_Heat_Flux,Transfer_Q_Derivatives, 0);                           %----------------------------------------------------------------            % L2-Error for the given system            %----------------------------------------------------------------            Theta((n-1) * length(Denominator_Distribution(:,1)) + d) = ...            sum((Simulated_Temperature - Transfer_Temperature).^2);                             currentTimeStep = currentTimeStep + 1; 			% d + (n-1)*length(Denominator_Distribution(:,1)) + (j-1)*length(Denominator_Distribution(:,1))*length(Numerator_Distribution(:,1)) + (i-1)*length(Denominator_Distribution(:,1))*length(Numerator_Distribution(:,1))*length(Calibration_Temperature(:,1,1)) 			A(currentTimeStep) = d + length(Denominator_Distribution(:,1))*(n+1+length(Numerator_Distribution(:,1))*(j-1+(i-1)*length(Calibration_Temperature(:,1,1))));            progress = currentTimeStep /...                 % progress increases from 0 to 1                   (length(Calibration_Temperature(:,1,1)) ^ 2 * ...                    length(Numerator_Distribution(:,1)) * ...                    length(Denominator_Distribution(:,1)));            if progress > kk                multiWaitbar('Automatic Parameter Selection',progress);                kk=kk+0.001;                                  % with kk the output rate is reduced            end          end               end      %----------------------------------------------------------------      % Selecting best fit and port      %----------------------------------------------------------------      [~, Position] = min(Theta);       Denominator_Index   = mod(Position,length(Denominator_Distribution(:,1)));        if Denominator_Index == 0           Denominator_Index = length(Denominator_Distribution(:,1));       end       Numerator_Index     = (Position - Denominator_Index) / ...                                length(Denominator_Distribution(:,1))+1;                           clear Local_Numerator_Grid Local_Denominator_Grid Transfer_Q_Derivatives      [Position] = find(Numerator_Distribution(Numerator_Index,:));         for m = 1:length(Position)       Transfer_Q_Derivatives(:,m) =  Heat_Flux_Derivatives(:,Position(m));       end       for Generic_Counter = 1:length(Position)           Local_Numerator_Grid(:,Generic_Counter) = ...           Numerator_Grid(:,Position(Generic_Counter));       end       clear Transfer_T_Derivatives       [Position] = find(Denominator_Distribution(Denominator_Index,:));        for m = 1:length(Position)       Transfer_T_Derivatives(:,m) =  Temperature_Derivatives(:,Position(m));       end       for Generic_Counter = 1:length(Position)           Local_Denominator_Grid(:,Generic_Counter) = ...           Denominator_Grid(:,Position(Generic_Counter));       end                                                             [Numerator_Order,Numerator_Parameter,Denominator_Order, ...       Denominator_Parameter,Error_Numerator,Error_Denominator] ...       = system_identification(Transfer_Q_Derivatives,Transfer_T_Derivatives, ...                              Local_Numerator_Grid, Local_Denominator_Grid, 0);                               [Simulated_Temperature] = simulation_system( ...                                Numerator_Parameter, Denominator_Parameter, ...                                Denominator_Order, Delta_t,Transfer_Heat_Flux, ...                                Transfer_Q_Derivatives, 0);  % refresh mulitWaitbar is suppresed (0 in last simulation_system - input), because so many simulated temperatures are calculated                              clear Discard Position Nominator_Index Denominator_Index         clear Local_Numerator_Grid Local_Denominator_Grid Generic_Counter            end %Auto_Param_Finder     %--------------------------------------------------------------------     % Equation impulse response via a numericaldirac impulse      %--------------------------------------------------------------------     Dirac_Impulse(1:length(Calibration_Temperature),1) = 0;         % Creating numerical      Dirac_Impulse(2,1)                                 = 1; % Dirac-Impulse --> eigentlich [J/m^2], d.h. 1/Delta_t - das muss aber auch beim Invertieren beachtet werden (IR muss *Delta_T gesetzt werden). Die Implementierung von 1/Delta_t muss noch erfolgen.%       Order                      = [ Numerator_Order ; Numerator_Parameter ];      Dirac_Impulse_Derivatives  = derivative(Dirac_Impulse, Numerator_Order, Delta_t);                                              [Response] = simulation_system( Numerator_Parameter, ...                                     Denominator_Parameter,Denominator_Order, ...                                     Delta_t,Dirac_Impulse,Dirac_Impulse_Derivatives, 1);                                        %--------------------------------------------------------------------      % Integrating equated parameters into the main program data structure      %--------------------------------------------------------------------      Numerator_Order_Vector{i,j}         = Numerator_Order;      Numerator_Parameter_Vector{i,j}     = Numerator_Parameter;      Denominator_Order_Vector{i,j}       = Denominator_Order;      Denominator_Parameter_Vector{i,j}   = Denominator_Parameter;      Error_Numerator_Vector{i,j}         = Error_Numerator;      Error_Denominator_Vector{i,j}       = Error_Denominator;      Simulated_Temperature_Vector(i,j,:) = Simulated_Temperature;      Impulse_Response(i,j,:)             = Response;            clear Numerator_Order Numerator_Parameter Denominator_Order       clear Denominator_Parameter Error_Nominator Error_Denominator      clear Response           endendend   