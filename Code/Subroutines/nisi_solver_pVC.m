function [Msrmnt_Heat_Flux] = nisi_solver_pVC(Msrmnt_Temperature,Impulse_Response,...                                    Delta_t,Penetration_Time,Future_Time_Window)%% Solver using phased Van-Cittert Penetration_Steps                         = double(int32(Penetration_Time/Delta_t));Future_Time_Steps                         = double(int32(Future_Time_Window/Delta_t));Impulse_Response(:,:,1:Penetration_Steps) = 0;% Impulse_Response                          = Impulse_Response * Delta_t; % Korrektur zu Impulsantwort, eines Dirac Impulses von 1 W/m^2 (von 1 J/m^2)Datapoints                                = length(Msrmnt_Temperature(1,:));Msrmnt_Points                             = length(Msrmnt_Temperature(:,1));kk = 0;Msrmnt_Heat_Flux = zeros(Msrmnt_Points,Datapoints);delta_Temperature = zeros(Msrmnt_Points,1+Future_Time_Steps);Heat_Flux_Buffer = zeros(1,1+Future_Time_Steps);% h = waitbar(0,'','Name','Inverting System...');for currentTimeStep = 1:length(Msrmnt_Temperature(1,:)) - Penetration_Steps - Future_Time_Steps  %------------------------------------------------------------------------  % Determine the temperature at timestep induced by heat flux equated  % for previous timesteps  %------------------------------------------------------------------------   for handle_Sensor = 1:Msrmnt_Points         Induced_Temperature = 0;         for handle_Surface = 1:Msrmnt_Points           iA(1,:) = Msrmnt_Heat_Flux(handle_Surface,:);           iB(1,:) = Impulse_Response(handle_Sensor,handle_Surface,:);           ConvBuff = conv(iB,iA);            Induced_Temperature = Induced_Temperature + ConvBuff(1:Datapoints);         end         for virtual_time_steps = 1:1+Future_Time_Steps            delta_Temperature(handle_Sensor,virtual_time_steps) = Msrmnt_Temperature( ...            handle_Sensor,currentTimeStep+Penetration_Steps+virtual_time_steps-1) -  ...            Induced_Temperature(1,currentTimeStep+Penetration_Steps+virtual_time_steps-1);         end  end%--------------------------------------------------------------------------% Solving linear equation System%% delta_Temperature(s,x) = Sum( Msrmnt_Heat_Flux(k,i)*Impulse_Response(s,k,i+x)) for all s%--------------------------------------------------------------------------  for timestep_Offset = 1:1 + Future_Time_Steps       Heat_Flux_Buffer(:,timestep_Offset) = ...      Impulse_Response(:,:,1 + Penetration_Steps + timestep_Offset)\delta_Temperature(:,timestep_Offset);      for stabilisation_counter = 1:length(Heat_Flux_Buffer(:,1))          if Heat_Flux_Buffer(stabilisation_counter,timestep_Offset) < 0             Heat_Flux_Buffer(stabilisation_counter,timestep_Offset) = 0;          end      end  end%--------------------------------------------------------------------------  % Approximating the final solution by weighted error handling of the % Impulse Response%--------------------------------------------------------------------------      for handle_Surface = 1:Msrmnt_Points          Msrmnt_Heat_Flux(handle_Surface,currentTimeStep) = ...          sum(Heat_Flux_Buffer(handle_Surface,:))/(1 + Future_Time_Steps );      end            progress=currentTimeStep /(length(Msrmnt_Temperature(1,:))-Penetration_Steps-Future_Time_Steps);      if progress > kk                                   % progress increases from 0 to 1      multiWaitbar('Inverting System',progress);      kk=kk+0.001;                                        % with kk the output rate is reduced to every 0.1%      end      endmultiWaitbar('Inverting System',1);end